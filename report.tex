\documentclass[a4paper,12pt,twocolumn]{article}

\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{a4wide}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage{cite}

\usepackage{lipsum}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}

\lhead{Axel Angel}
\rhead{Scala BlitzView}
\chead{Report}
\rfoot{Page \thepage\ of \pageref{LastPage}}
\lfoot{\today}

\pdfinfo{
    /Author (Axel Angel)
    /Title (Scala BlitzView)
    /Subject (Report)
    }

\begin{document}
\section*{Abstract}
Scala is a powerful language which currently provides a built-in library for non-strict views with some important shortcomings for the users such as unexpected and unintuitive behaviors.
In this work we created a new library, based on Scala Blitz, to provide lightweight, non-strict and parallel-efficient collections, we call them Views.
% 1/2 lines of desc

\section{Introduction}
% subject of the work
% scala (powerful, fast-moving lang
% standard collections, non-strict and views
Scala is a powerful and fast-moving language that fuses object-oriented programming with a wide range of function programming concepts \cite{scala-overview}.
It runs on the JVM and as such it stays compatible with Java and its ecosystem.
Scala itself provides an important number of libraries, for example Scala collection, which implements Lists, Arrays, Maps and Sets with immutable and mutable variants.
They are more in accord within the Scala environment than the Java collections, moreover they provide the functional programming concepts like constructors.

A {\it View} in Scala is a non-strict version of some collection set.
Non-strictness here is a mean to post-pone computations over a collection until the final result is actually needed.
The View is said to be {\it forced} when the computation need to be performed over all the elements.
A View captures the operations that are postponed over its inner collection in constant memory $O(1)$ and stacks them to provide efficient computation in a single pass over the collection $O(n)$.

In practice this is used when multiple operations, such as multiple \verb%map% and \verb%filter%, are called consecutively.
As Views are usually {\it immutable}, as in our design, performing a new operation actually returns a new View where all previous operations are captured along the new one.
Immutability greatly simplifies the implementation and open new possibilities for the programmer to combine and reuse Views in his code.

Therefor a View allows us to use special optimisations such as merging these operations to compute them all at once for each element of the inner collection.
As the operations are done element by element, we can split the inner collections into a dynamic number of chunks and compute the operations in parallel depending on the number of cores of the computer.

The design of the Views API is primordial because it can greatly limit the optimisations thus influencing the efficiency of the computations, as far as deciding whether they can be done in parallel and not.
There exists two types of operations over Views:
\begin{description}
    \item[Stackable:] These can be postponed and captured in the View without evaluating (forcing) the elements, eg: \verb%map% and \verb%filter%. Usually their type is \verb%[a] -> [b]%.
    \item[Folding:] These are the last operations that actually force the View to be computed and in general returns a single element, eg: \verb%aggregate% and \verb%max%. Usually their type is \verb%[a] -> b%.
\end{description}
In this work, we focused on a powerful subset of the actual Scala collections API to preserve the efficiency of the Views while providing very powerful and functional non-strict collections.

\section{Previous work}
% scala views, broken
% talk about java 8 streams, limitations/bad design? (adv: unboxed?)
% (java: problem type dependent)
\lipsum[2]

\section{Views}
% what operations/methods make sense?
% why scala views broken, which methods useless (never finish)
% (flatten -> list, permutations)
% use inherited collections API -> broken
% problem of inefficiency, why cannot implement certain?
\lipsum[3]

\section{Design}
% hierarchy: interface trait, impl-spec trait, classes
% implicit extension: ext-method, evidence
\lipsum[4]

\section{Usability}
% external trait, interface
\lipsum[5]

\section{Extensibility}
% internal trait, how to extend, aggInternal, BlitzViewImpl
\lipsum[6]

\section{Conclusion}
% future work, what's next?
\lipsum[7]

\bibliography{report}{}
\bibliographystyle{plain}


\end{document}
