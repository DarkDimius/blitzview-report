\documentclass[a4paper,12pt,twocolumn]{article}

\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{a4wide}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage{cite}

\usepackage{lipsum}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}

\lhead{Axel Angel}
\rhead{Scala BlitzView}
\chead{Report}
\rfoot{Page \thepage\ of \pageref{LastPage}}
\lfoot{\today}

\pdfinfo{
    /Author (Axel Angel)
    /Title (Scala BlitzView)
    /Subject (Report)
    }

\begin{document}

\begin{abstract}
% 1/2 lines of desc
Scala is a powerful language which currently provides a built-in library for non-strict views with some important shortcomings for the users such as unexpected and unintuitive behaviors.
In this work we created a new library, based on Scala Blitz, to provide lightweight, non-strict and parallel-efficient collections, we call them Views.
We present the library API design, implementation and how programmers can use and extend it.
\end{abstract}

\section{Introduction}
% subject of the work
% scala (powerful, fast-moving lang
% standard collections, non-strict and views
Scala is a powerful and fast-moving language that fuses object-oriented programming with a wide range of function programming concepts \cite{scala-overview}.
It runs on the JVM and as such it stays compatible with Java and its ecosystem.
Scala itself provides an important number of libraries, for example Scala collection, which implements Lists, Arrays, Maps and Sets with immutable and mutable variants.
They are more in accord within the Scala environment than the Java collections, moreover they provide the functional programming concepts like constructors.

A {\it View} in Scala is a non-strict version of some collection set.
{\it Non-strictness} here is a mean to post-pone computations over a collection until the final result is actually needed, this type of view is called a proxy.
The View is said to be {\it forced} when the computation need to be performed over all the elements.
A View captures the operations that are postponed over its inner collection in constant memory $O(1)$ and stacks them to provide efficient computation in a single pass over the collection $O(n)$.

In practice this is used when multiple operations, such as multiple \verb|map| and \verb|filter|, are called consecutively.
As Views are usually {\it immutable}, as in our design, performing a new operation actually returns a new View where all previous operations are captured along the new one.
Immutability greatly simplifies the implementation and open new possibilities for the programmer to combine and reuse Views in his code.

Therefor a View allows us to use special optimisations such as merging these operations to compute them all at once for each element of the inner collection.
As the operations are done element by element, we can split the inner collections into a dynamic number of chunks and compute the operations in parallel depending on the number of cores of the computer.

The design of the Views API is primordial because it can greatly limit the optimisations thus influencing the efficiency of the computations, as far as deciding whether they can be done in parallel and not.
There exists two types of operations over Views:
\begin{description}
    \item[Transformers:] These can be postponed and captured in the View without evaluating (forcing) the elements, eg: \verb|map| and \verb|filter|. Usually their type is \verb|[a] -> [b]|.
    \item[Folders:] These are the last operations that actually force the View to be computed and in general returns a single element, eg: \verb|aggregate| and \verb|max|. Usually their type is \verb|[a] -> b|.
\end{description}
In this work, we focused on a powerful subset of the actual Scala collections API to preserve the efficiency of the Views while providing very powerful and functional non-strict collections.

\section{Previous work}
Scala and its collection offer a large toolbox of functions taken from functional paradigm such as \verb|flatMap| and \verb|aggregate| in a object-oriented hierarchy of classes with common interfaces.
This collection interface is declared in the parent class \verb|Traversable|\cite{scala-collections} which is inherited by multiple types of collection in order to provide a common API that operates uniformly on all these different structures transparently for the programmer: whatever he uses is a \verb|List|, an \verb|Array|, a \verb|Map|, a \verb|LinkedList| or any descent of these classes, they all share this common methods.
The programmer has to learn and understand it once, then he can use his experience for any of these collections easily: it's intuitive and greatly increase the productivity.
The built-in collections in Scala are strict in the sense all operations are directly computed because Scala is a strict language, although the programmer can specify the \verb|lazy| variable-keyword, this doesn't solve the problem optimally.

% scala views, broken
Since Scala 2.8, the Views joined the built-in toolbox to offer non-strict collections using the common interface of collections.
They allow to create a proxy over a collection that captures the operations on them until an operation force it.
The purpose of the proxy is to change the evaluation strictness of the collections by handling the computation itself when it see fits.
For example a call to \verb%flatMap% over a View returns immediately whereas over a strict collection this may take some time to return.
This is done by implementing all methods of the collection interface in a way the operations are remembered and done when necessary
This design decision has great advantages when it comes to people experienced with Scala collections because there is no external difference between them.
Unfortunately it has two important costs for Scala in terms of the implementation and for the programmer who expect consistent and efficiently results.
We will develop these aspects in the section and how we approached differently the problem.

% talk about java 8 streams, limitations/bad design? (adv: unboxed?)
% (java: problem type dependent)

\section{Views}
% what operations/methods make sense?
% why scala views broken, which methods useless (never finish)
% (flatten -> list, permutations)
% use inherited collections API -> broken
% problem of inefficiency, why cannot implement certain?
\lipsum[3]

\section{Design}
% hierarchy: interface trait, impl-spec trait, classes
% implicit extension: ext-method, evidence
\lipsum[4]

\section{Usability}
% external trait, interface
\lipsum[5]

\section{Extensibility}
% internal trait, how to extend, aggInternal, BlitzViewImpl
\lipsum[6]

\section{Conclusion}
% future work, what's next?
\lipsum[7]

\bibliography{report}{}
\bibliographystyle{plain}


\end{document}
